RENA CANGA          1115201700218

Δομές :
    -Binary Tree -> Εγγραφές των ασθενών
    -HashTable -> Ένα με τιμή κατακερματισμού τη χώρα και ένα με τιμή την ασθένεια
                  Ενα bucket εχει ενα δεικτη σε πινακα απο struct value. Ενα struct value εχει εναν δεικτη σε ΡΒΤ δεντρο και ενα ονομα κλειδι.
                  Το μεγεθος του πινακα ειναι αναλογο του μεγεθους του bucket.
    -Red Black Tree -> Εγγραφές σε ασθενείς σορτατισμενα με τη ημερομηνία εισαγωγής ανάλογα το πίνακα κατακερματισμού
    -MaxHeap-> ενα complete sorted binaty tree.

Option : διαβάζει από τη γραμμή εντολής τη εντολή και αναλόγως δεσμεύει μνήμη καλεί την συνάρτηση και αποδεσμεύει την μνήμη που δεν χρειάζεται πλέον
ΙΝΙΤ Δημιουργεί όλες τις δομές και καθώς διαβάζει από το αρχείο τις εγγραφές δεσμεύει χώρο για αυτές και τα τοποθετεί στις δομές

globalDiseaseStats -> Χρησιμοποιεί τη globalDiseaseStats, χωρίς ορίσματα country και virus. Καλείτε η allDiseases, η οποία ανατρέχει όλο το πίνακα κατ. και για κάθε γεμάτο
                      μπακετ μετράει τους ασθενείς με την countPatientsRBTByCountry και εκτυπώνει το count.
                      Αν τα date1, date2 δεν είναι ορισμένα(NULL) τότε τα μετράει χωρίς περιορισμό ημερομηνίας
diseaseFrequency -> Χρησιμοποιεί τη globalDiseaseStats, άλλα με ορίσματα country και virus. Αν δεν έχουν οριστεί οι ημερ. εκτυπώνει μήνυμα
                    λάθους και τελειώνει η εκτέλεση, αλλιώς καλείτε η allDiseases, η οποία έχει δυο εκδώσεις μια που ορίζεται η χώρα και η άλλη όπου η χώρα είναι NULL.
                    Και στις δυο περιπτώσεις καλείτε η FindPatientHTDisease, η οποία χασαρει την ασθένεια και επιστρέφει πόιντερ στη δομή που κρατάει το RBT δείκτη
                    και καλεί την  συνάρτηση countPatientsRBTByCountry, η οποία μετράει τους ασθενείς
                    της κάθε χώρας που έχουν Country = country και το entryDate είναι στο διάστημα date1, date2.
topkDiseases -> Καλεί τη συνάρτηση allCountriesByDisease, η οποία ανατρέχει όλο το πινάκα κατ. και για κάθε γεμάτο μπακετ μετράει τους ασθενείς
                της κάθε χώρας που έχουν Country = country και το entryDate είναι στο διάστημα date1, date2. Αν τα date1, date2 δεν είναι ορισμένα(NULL) τότε τα μετράει χωρίς
                περιορισμό ημερομηνίας. Καλείται η insert ,η οποία δημιουργεί on the fly ένα MaxHeap και εισάγει το count και το ανάλογο Disease στη δομή Όταν τελειώσει
                την ανάγνωση του HashTable θα τυπώσει τις τοπ κ ασθένειες. Τέλος διαγράφετε η δομή αυτή
topkCountries -> Καλεί τη συνάρτηση allDiseasesByCountry, η οποία ανατρέχει όλο το πινάκα κατ. και για κάθε γεμάτο μπακετ μετράει τους ασθενείς
                 της κάθε χώρας που έχουν Disease = virus και το entryDate είναι στο διάστημα date1, date2. Αν τα date1, date2 δεν είναι ορισμένα(NULL) τότε τα μετράει χωρίς
                 περιορισμό ημερομηνίας. Καλείται η insert ,η οποία δημιουργεί on the fly ένα MaxHeap και εισάγει το count και το ανάλογο Country στη δομή Όταν τελειώσει
                 την ανάγνωση του HashTable θα τυπώσει τις τοπ κ χώρες. Τέλος διαγράφετε η δομή αυτή
insertPatientRecord -> initialize έναν νέο ασθενή και ενημερώνει της δομές Binary Tree και HashTable
recordPatientExit -> Καλεί τη συνάρτηση FindPatient, η οποία τρέχει αναδρομικά το Binary Tree και επιστρέφει το δείκτη στον ασθενή με recordId. Ελέγχει αν ο ασθενής δεν έχει
                      exitDate και κάνει ενημέρωση την έγγραφη, αλλιώς εκτυπώνει μήνυμα Αν η εγγραφή δεν υπάρχει επιστρέφει κωδικό λάθους και σταματάει η εκτέλεση.
numCurrentPatients -> Μέσω της συνάρτησης FindPatientHTDisease, η οποία χασαρει την ασθένεια και επιστρέφει ποιντερ στη δομή που κρατάει το RBT δείκτη,
                      και καλεί την  συνάρτηση countCurrentPatientsRBT με το όρισμα αυτό, η οποία μετράει τις έγγραφες με exitDate = "-". Αν η εγγραφή δεν
                      υπάρχει επιστρέφει κωδικό λάθους και σταματάει η εκτέλεση
Exit -> Αποδεσμεύει όλοι τη μνήμη (Δομές και εγγραφές ασθενών)

Εκτύπωση του MaxHeap ->
                Καθώς διαβαζει ανα επιπεδο(GivenLevel) αποθηκευει τις τιμες σε ενα πινακα(απο δεικτες) μεγεθους κ(ArrayEntry) και ελεγκει αν το πρωιγουμενο ελεμεντ ειναι μεγαλυτερου μεγεθους(FixArray). Αν ναι κανει
                σουαπ τους δεικτες των τιμων μεχρη το στοιχειο να τοποθετηθει την θεση του.
                Αν ο πινακας ειναι γεματος ελεγκει αν το τελευταιο στοιχειο ειναι μικροτερο του στοιχειου που διαβαζει στη σειρα(FixArrayLeftover), αν ναι ανατικαταστα το τελευταιο με το
                καινουριο και καλει την συναρτηση FixArray για να το τοποθετηση στη θεση του.